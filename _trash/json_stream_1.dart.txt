// // ignore_for_file: prefer_final_fields

// import 'dart:async';

// /// {"k1": "v1", "k2": "v2", "k3": {"k3.1": "v3.1", "k3.2": ["v3.2[0]", 1, true]}}
// /// ^

// class JsonStream {
//   final Stream<String> _stream;
//   JsonStream({required Stream<String> stream})
//     : _stream = stream.asBroadcastStream() {
//     _stream.listen((chunk) => _parseChunk(chunk));
//   }

//   // * PUBLIC GETTERS
//   Future<T> getPropertyFuture<T>(String key) {
//     return _propertyCompleters.putIfAbsent(key, () => Completer()).future
//         as Future<T>;
//   }

//   Stream<String> getPropertyStream(String key) {
//     return _stringPropertyStreamControllers
//         .putIfAbsent(key, () => StreamController.broadcast())
//         .stream;
//   }

//   // * INTERNAL HELPERS
//   void _addStringToStreams(String value) {
//     _streamController.add(value);
//     print("\tADD:\n\t|$value|");
//     for (final key in _streamingKeys) {
//       _stringPropertyStreamControllers
//           .putIfAbsent(key, () => StreamController.broadcast())
//           .add(value);
//     }
//   }

//   void _nestNewKey(String key) {
//     final prefixKey = _streamingKeys.isNotEmpty
//         ? "${_streamingKeys.last}."
//         : "";
//     final newKey = "$prefixKey$key";
//     _streamingKeys.add(newKey);

//     print("\t[NEW KEY]\n\tSHORT: $key\n\tFULL: $newKey");
//   }

//   void _removeLastKey() {
//     if (_streamingKeys.isEmpty) return;
//     _streamingKeys.remove(_streamingKeys.last);
//   }

//   // * PUBLIC PROPERTIES
//   Future<Map<String, dynamic>> get map => _mapCompleter.future;
//   Stream<String> get stream => _streamController.stream;

//   // * INTERNAL STATES
//   final Map<String, StreamController<String>> _stringPropertyStreamControllers =
//       {};
//   final Map<String, Completer<Object?>> _propertyCompleters = {};

//   Completer<Map<String, dynamic>> _mapCompleter = Completer();
//   StreamController<String> _streamController = StreamController.broadcast();

//   Set<String> _streamingKeys = {};
//   String _persistentBuffer = "";
//   var _parserState = _JsonStreamParserState.readingNothing;
//   bool _inString = false;

//   /// {"root": {"sib1": "hello world", "sib2": "goodbye", "nesting": {"value": true}, "nestDown": "fdfsd"}}
//   ///          ^
//   FutureOr<void> _parseChunk(String chunk) {
//     // ! SOLELY FOR OUTPUTING CHUNKS IN STRING VALUES, THATS IT
//     String streamChunkBuffer = "";
//     print("\n==============\nCHUNK:\t[ $chunk ]");
//     for (final character in chunk.split("")) {
//       print("[$character]");
//       final String CHAR_ = character;
//       if (!_inString) {
//         // * IF NOT IN STRING
//         if (character == '"') {
//           streamChunkBuffer += character;
//           _inString = true;
//           continue;
//         }
//         if (character == "{") {
//           _parserState = _JsonStreamParserState.readingKey;
//           streamChunkBuffer += character;
//           continue;
//         }
//         if (character == "}") {}
//         if (character == "[") {}
//         if (character == "]") {}
//         if (character == ":") {
//           streamChunkBuffer += character;
//           _parserState = _JsonStreamParserState.readingValue;
//           final key = _persistentBuffer;
//           _nestNewKey(key);
//           _persistentBuffer = "";
//           continue;
//         }

//         continue;
//       }

//       if (_inString) {
//         // * IF IN STRING

//         if (character == r"\") {}
//         if (character == '"') {
//           streamChunkBuffer += character;
//           _inString = false;
//           continue;
//         }

//         if (_parserState == _JsonStreamParserState.readingKey) {
//           _persistentBuffer += character;
//           streamChunkBuffer += character;
//           continue;
//         }
//       }
//     }
//     // After iterating
//     _addStringToStreams(streamChunkBuffer);
//   }
// }

// enum _JsonStreamParserState {
//   readingNothing,
//   readingKey,
//   readingValue,
//   readingListValue,
// }

// enum _JsonStreamParserWait { waitingNothing, waitingType }
